---
title: "Autonomous Resistor Sorter - Blog #3"
date: 2022-10-29


---

## Resistor Separation Subsystem
The finalization of the separation subsystem circuit has been completed, including the code and installation of the parts. For organization, the cables shown in the picture have been extended. Initially, these extensions were soldered but not covered with electrical tape. This was due to the desire to verify that the extensions would work before sealing them off.

Figure 1 Initial Separation Circuit

Complications arose due to the exposed soldering points on the wires between the motor and the control circuit. During the first rounds of testing after the additional wire was added, the positive and negative wires exposed points contacted one another. This caused a short that burnt out the circuit connection between two points, after which the circuit no longer worked. Circuit analysis was performed to verify the damaged link and if it was exclusive to exist between the two points. A bridge was added in parallel to connect the two damaged points, and after which the circuit functioned once again.

Figure 2 Vibration Motor Circuit Repair

With the return of function of the vibration circuit, simple case testing could begin. A basic version of the designed setup was constructed on a breadboard, where testing using objects to trigger the programmed reaction. A hand and resistors of varying sizes were used in the testing to prove functionality. The following link is to a Dropbox video giving a demonstration of the basic circuit testing.
https://www.dropbox.com/s/gn49cvh90hivkk7/IMG_2308.MOV?dl=0
 
After basic testing was completed, physical and electrical components were then combined for subsystem tests. This required purchasing of the last separation subsystem component. A flex clamp mount is used to hold the laser pointer in place during subsystem function.

Figure 3 Flex Clamp Laser Pointer Mount

The final testing found that some resistors with larger leads would trigger the trip function early. However, after several adjustments and retests, an analog value that minimized both early tripping and miss trips was found. The following link is to a Dropbox video giving a demonstration of circuit function in its working environment.
https://www.dropbox.com/s/yrvi6yx1sivwlbf/IMG_2322.MOV?dl=0
 

## Conveyor Belt, Storage & Delivery System Integration
For the Storage & Delivery System, we reached completion of our subsystem integration. We have completed the physical assembly for the system, the integration of our microcontroller logic, and the testing of the individual sub-system with the conveyor belt. The delivery + storage subsystem still has some construction to complete, such as cleaning up the electrical components of the subsystem and printing 3D parts. However, these portions can and will be addressed during further integration and training of the neural network. Our Delivery and Storage Sub-System can store a resistor approximately every 4 seconds, giving the MLVS an extra 8 seconds to determine the value of the resistor. Please see below the figures of the Delivery and Storage subsystem: 
Fig. 4: Overview of Storage & Delivery System
Fig. 5: Speed Testing of the Conveyor Belt and Storage & Delivery Subsystem


## Machine Learning Vision System
As discussed in the future steps of blog 2, the main focus of the MLVS was to create a final dataset and deploy the model on to the Google coral. Another focus was to create and design a way to identify the colors of the bands.
For the band color classification problem, the first approach was to use an image classification model to classify the 11 different colors. Unfortunately, the model suffered from overfitting and had terrible results. Furthermore, the risk with the proposed approach discussed in Blog 2 was a reality as the cache on the google coral was not large enough to support two models. The loss function was not converging and resulted in a model accuracy of 21%. The second approach was to use a machine learning algorithm known as k-nearest-neighbors (knn) to classify the colors. This is a statistical algorithm, not a model, and does not rely on parameter caching which avoids the risk mentioned in blog 2. We decided this was our best approach and selected it for our color identification task. 
With our band detection model selected and band color classification algorithm selected, it was time to collect our final datasets. We created a MATLAB script to capture 500 images of resistors from the ECE Lab using a Logitech c922 webcam. This script is under Resistor_Capture.m at this repository https://github.com/georgeb20/AutonomousResistorSorter. The process for collecting images for the band detection model is the same as discussed in previous blogs. For the band color classification model, a python script was made to save the band crops of the labeled band images so we can use them for the color identification model. We gathered 30 color crops for each of the 11 colors leaving us with 330 images for the color classification dataset. We then used Roboflow, an online data augmentation tool to generalize our dataset by rotating images, applying flips, and creating new data from our existing data. We ended up with 1500 image examples for our band detection model and 990 images for the band color classification model. 


Figure 1. Example image from color band dataset.

We then trained the band detection model using our images and ended up with a decent mAP of 29.3%. As for our knn model, we ended up with an initial accuracy of 48% but with tweaks to the k parameter and image preprocessing, we were able to get it up to 67%.
Finally, we created an inference script to perform live inference on the Google Coral. The algorithm of the pipeline script is as follows.

Figure 2. Pipeline and algorithm for the inference script.

After an image frame is captured, it gets sent to a function to make sure it is a good photo. This essentially checks if there is something new in the frame. If it is, the frame is sent to the band detection model, then the color detection model, and finally the function that returns the resistance. 

Figure 3. An example result from the MLVS.

The MLVS is working as expected however it is suffering from low accuracy. This is due to the color classification having a low accuracy of 67%. The work period from Oct 29-Nov 19 will be to increase the color classificationâ€™s accuracy and also integrate the MLVS with the other subsystems. Currently, we plan on using a HC-05 bluetooth model to communicate between the microcontroller and the Google Coral to send the resistance information between devices.

